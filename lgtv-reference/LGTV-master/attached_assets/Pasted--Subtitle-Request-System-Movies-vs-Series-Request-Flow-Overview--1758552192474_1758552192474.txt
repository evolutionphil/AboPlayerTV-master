ğŸ“º Subtitle Request System - Movies vs Series
ğŸ—ï¸ Request Flow Overview
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Content Type  â”‚â”€â”€â”€â”€â”‚ Request Builder  â”‚â”€â”€â”€â”€â”‚   API Request       â”‚
â”‚ Movie | Episode â”‚    â”‚ Data Preparation â”‚    â”‚ exoapp.tv/api/      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                        â”‚
         â–¼                       â–¼                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Name Cleaning & â”‚    â”‚ TMDB ID Priority â”‚    â”‚   Success/Error     â”‚
â”‚ Pattern Removal â”‚    â”‚ Fallback Logic   â”‚    â”‚   Handling          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
ğŸ¬ 1. Movie Subtitle Requests
Movie Name Processing Pipeline:
// Movie Processing Flow (from vod_series_player.js line 768+)
if(this.current_movie_type === 'movies') {
    
    // Step 1: Get original movie name
    var original_name = this.current_movie.name;
    var cleaned_name = original_name;
    
    // Step 2: Extract year from name
    var year_match = cleaned_name.match(/\((\d{4})\)/);
    var extracted_year = null;
    if (year_match) {
        extracted_year = parseInt(year_match[1]);
        // Remove year from name: "Movie Name (2023)" â†’ "Movie Name"
        cleaned_name = cleaned_name.replace(/\s*\(\d{4}\)\s*/, '').trim();
    }
    
    // Step 3: Remove quality indicators that interfere with matching
    var quality_patterns = /\s*\b(HD|4K|1080p|720p|480p|BluRay|BRRip|WEB-DL|WEBRip|DVDRip|CAMRip|TS|TC|HDTV|PDTV|XviD|x264|x265|HEVC|DivX|AC3|AAC|MP3|Dubbed|Subbed)\b\s*/gi;
    cleaned_name = cleaned_name.replace(quality_patterns, ' ').trim();
    cleaned_name = cleaned_name.replace(/\s+/g, ' ').trim();
    
    // Step 4: Remove bracketed content (except years)
    cleaned_name = cleaned_name.replace(/\[.*?\]/g, '').trim();
    cleaned_name = cleaned_name.replace(/\{.*?\}/g, '').trim();
    cleaned_name = cleaned_name.replace(/\s+/g, ' ').trim();
    
    // Step 5: Build request data
    subtitle_request_data = {
        movie_name: cleaned_name,
        movie_type: 'movie'
    };
    
    // Step 6: Add TMDB ID (highest priority for matching)
    if(this.current_movie.tmdb_id) {
        subtitle_request_data.tmdb_id = this.current_movie.tmdb_id;
    }
    
    // Step 7: Add year for better matching
    if(extracted_year) {
        subtitle_request_data.year = extracted_year;
    } else if(this.current_movie.year) {
        subtitle_request_data.year = this.current_movie.year;
    }
}
Movie Request Examples:
Original Name	Cleaned Name	Request Data
"The Matrix (1999) [1080p BluRay]"	"The Matrix"	{movie_name: "The Matrix", movie_type: "movie", year: 1999}
"Inception 2010 4K UHD x265"	"Inception"	{movie_name: "Inception", movie_type: "movie"}
"Avengers Endgame (2019)"	"Avengers Endgame"	{movie_name: "Avengers Endgame", movie_type: "movie", year: 2019}
ğŸ“º 2. Series/Episode Subtitle Requests
Episode Processing with Dual Strategy:
// Series/Episode Processing Flow (from vod_series_player.js line 814+)
else {
    // SERIES EPISODES: Enhanced logic with episode name parsing fallback
    
    // Step 1: Extract episode name from multiple possible properties
    var episode_name = this.current_movie.title || 
                      this.current_movie.name || 
                      this.current_movie.episode_name || '';
    
    subtitle_request_data = {
        movie_type: 'episode'
    };
    
    // **PRIMARY STRATEGY**: Use episode TMDB ID
    if(this.current_movie && this.current_movie.info && this.current_movie.info.tmdb_id) {
        subtitle_request_data.tmdb_id = String(this.current_movie.info.tmdb_id);
    } 
    // **FALLBACK STRATEGY**: Parse episode name for series info
    else {
        var parsed_episode = this.parseEpisodeName(episode_name);
        
        if(parsed_episode.series_name) {
            // Format as single string: "the witcher s01 e01"
            var formatted_name = parsed_episode.series_name.toLowerCase();
            
            if(parsed_episode.season_number && parsed_episode.episode_number) {
                var season_str = 's' + String(parsed_episode.season_number).padStart(2, '0');
                var episode_str = 'e' + String(parsed_episode.episode_number).padStart(2, '0');
                formatted_name = formatted_name + ' ' + season_str + ' ' + episode_str;
            }
            
            subtitle_request_data.movie_name = formatted_name;
            
            // Use series TMDB ID if available
            if(this.current_movie.info && this.current_movie.info.tmdb_id) {
                subtitle_request_data.id = String(this.current_movie.info.tmdb_id);
            }
        } else {
            // No pattern recognized - let API auto-detect
            subtitle_request_data.movie_type = 'auto';
        }
    }
}
Episode Name Parser Logic:
// Enhanced Episode Name Parser (from vod_series_player.js line 57+)
parseEpisodeName: function(episodeName) {
    var result = {
        series_name: null,
        season_number: null,
        episode_number: null,
        episode_title: null
    };
    
    if (!episodeName || typeof episodeName !== 'string') {
        return result;
    }
    
    var cleaned_name = episodeName.trim();
    
    // Step 1: Remove country/language codes (TR:, ES:, EN:, etc.)
    cleaned_name = cleaned_name.replace(/^[A-Z]{2}:\s*/i, '');
    
    // Step 2: Try multiple season/episode patterns
    var season_episode_patterns = [
        // "Series Name S01 E01" or "Series Name S01E01"
        /^(.+?)\s+S(\d{1,2})\s*E(\d{1,2})(?:\s*-\s*(.+))?$/i,
        // "Series Name Season 1 Episode 1"
        /^(.+?)\s+Season\s+(\d{1,2})\s+Episode\s+(\d{1,2})(?:\s*-\s*(.+))?$/i,
        // "Series Name 1x01" or "Series Name 1x1"
        /^(.+?)\s+(\d{1,2})x(\d{1,2})(?:\s*-\s*(.+))?$/i,
        // "Series Name (2023) S01E01"
        /^(.+?)\s*\(\d{4}\)\s*S(\d{1,2})E(\d{1,2})(?:\s*-\s*(.+))?$/i
    ];
    
    // Try each pattern
    for (var i = 0; i < season_episode_patterns.length; i++) {
        var match = cleaned_name.match(season_episode_patterns[i]);
        if (match) {
            result.series_name = match[1].trim();
            result.season_number = parseInt(match[2]);
            result.episode_number = parseInt(match[3]);
            if (match[4]) {
                result.episode_title = match[4].trim();
            }
            break;
        }
    }
    
    // Step 3: If no pattern found, extract just series name
    if (!result.series_name) {
        var series_only = cleaned_name
            .replace(/\s*\(.*?\)/g, '') // Remove parentheses content
            .replace(/\s*\[.*?\]/g, '') // Remove brackets content  
            .replace(/\s*\{.*?\}/g, '') // Remove curly braces content
            .replace(/\s*-\s*Episode.*$/i, '') // Remove "- Episode X" suffix
            .replace(/\s*Ep\s*\d+.*$/i, '') // Remove "Ep 1" suffix
            .replace(/\s+/g, ' ') // Normalize spaces
            .trim();
            
        if (series_only && series_only.length > 2) {
            result.series_name = series_only;
        }
    }
    
    // Step 4: Clean and normalize the series name
    if (result.series_name) {
        result.series_name = result.series_name
            .replace(/\s*\(.*?\)/g, '') // Remove remaining parentheses
            .replace(/\s*\[.*?\]/g, '') // Remove remaining brackets
            .replace(/\s*\{.*?\}/g, '') // Remove remaining braces
            .replace(/[^\w\s&'-]/g, ' ') // Keep only safe characters
            .replace(/\s+/g, ' ') // Normalize multiple spaces
            .trim();
    }
    
    return result;
}
Episode Request Examples:
Original Episode Name	Parsed Data	Request Data
"The Witcher S01 E01"	{series_name: "The Witcher", season: 1, episode: 1}	{movie_name: "the witcher s01 e01", movie_type: "episode"}
"Game of Thrones Season 2 Episode 5"	{series_name: "Game of Thrones", season: 2, episode: 5}	{movie_name: "game of thrones s02 e05", movie_type: "episode"}
"Breaking Bad 3x07 - One Minute"	{series_name: "Breaking Bad", season: 3, episode: 7}	{movie_name: "breaking bad s03 e07", movie_type: "episode"}
"TR: Stranger Things (2016) S04E01"	{series_name: "Stranger Things", season: 4, episode: 1}	{movie_name: "stranger things s04 e01", movie_type: "episode"}
ğŸŒ 3. API Request Structure
AJAX Request Configuration:
// API Request (from vod_series_player.js line 857+)
$.ajax({
    method: 'post',
    url: 'https://exoapp.tv/api/get-subtitles',
    data: subtitle_request_data,
    dataType: 'json',
    success: function(result) {
        that.subtitle_loading = false;
        $('#subtitle-loader-container').hide();
        
        if(result.status === 'success') {
            if(result.subtitles && result.subtitles.length > 0) {
                // Store API subtitles
                media_player.subtitles = result.subtitles;
                that.renderSubtitles(kind, media_player.subtitles);
                that.subtitle_loaded = true;
            } else {
                // No API subtitles found - fallback to native
                that.useNativeSubtitleFallback();
            }
        } else {
            // API error - use native subtitles
            that.useNativeSubtitleFallback();
        }
    },
    error: function(xhr, status, error) {
        that.subtitle_loading = false;
        $('#subtitle-loader-container').hide();
        // Network/API error - fallback to native subtitles
        that.useNativeSubtitleFallback();
    }
});
Request Data Examples:
Movie Request:

POST https://exoapp.tv/api/get-subtitles
{
    "movie_name": "The Matrix",
    "movie_type": "movie",
    "year": 1999,
    "tmdb_id": "603"
}
Series Request (with TMDB ID):

POST https://exoapp.tv/api/get-subtitles
{
    "movie_type": "episode",
    "tmdb_id": "1234567"
}
Series Request (with parsed name):

POST https://exoapp.tv/api/get-subtitles
{
    "movie_name": "the witcher s01 e01",
    "movie_type": "episode",
    "id": "71912"
}
ğŸ“¨ 4. Response Handling
API Response Structure:
{
    "status": "success",
    "subtitles": [
        {
            "label": "English",
            "file": "/subtitles/movie123/en.srt",
            "language": "en"
        },
        {
            "label": "Spanish", 
            "file": "/subtitles/movie123/es.srt",
            "language": "es"
        }
    ]
}
Fallback Strategy:
// Three-level fallback system:
// 1. API Subtitles (Primary)
if(result.subtitles && result.subtitles.length > 0) {
    media_player.subtitles = result.subtitles;
    // Use API subtitles
}
// 2. Native TV Subtitles (Secondary)  
else {
    var nativeSubtitles = that.safeGetTracks('TEXT');
    if (nativeSubtitles && nativeSubtitles.length > 0) {
        // Use native TV subtitles
        that.renderSubtitles('TEXT', nativeSubtitles);
        showToast("Info", "Enhanced subtitles unavailable. Using native subtitles.");
    }
    // 3. No Subtitles (Final fallback)
    else {
        that.showEmptySubtitleMessage(kind);
    }
}
ğŸ” 5. Key Differences Summary
Aspect	Movies	Series/Episodes
Primary ID	tmdb_id (movie)	tmdb_id (episode-specific)
Name Processing	Clean quality indicators, extract year	Parse season/episode patterns
Fallback Logic	Clean name + year	Episode name parsing
Request Type	movie_type: "movie"	movie_type: "episode"
Name Format	"Clean Movie Name"	"series name s01 e01"
Additional Fields	year	season_number, episode_number
This comprehensive system ensures ma